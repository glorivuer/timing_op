好的，将Puppeteer脚本转为`headless: true`并在Ubuntu上长期稳定运行，这是一个非常实际且重要的需求。您现有的`run.sh` + `tsx`脚本的组合是一个不错的起点，但要实现工业级的稳定性（“不宕机”），我们需要从**脚本自身、进程管理、系统环境**和**监控**四个层面进行加固。

### 总结：关键行动清单（TL;DR）

1.  **使用PM2代替`run.sh`**：这是最重要的一步，它提供了自动重启、日志管理和性能监控。
2.  **在脚本中加入定期重启浏览器的逻辑**：每运行N次循环后，关闭并重新创建`browser`实例，防止内存泄漏。
3.  **增加系统级的僵尸进程清理**：设置一个`cron`任务，定期清理可能残留的Chrome进程。
4.  **优化Puppeteer启动参数**：使用`--disable-dev-shm-usage`来避免因共享内存不足导致的崩溃。

---

下面是详细的分析和实施方案：

### 层面一：脚本自身的健壮性 (Script-Level Hardening)

即使外部工具再强大，如果脚本本身有内存泄漏或逻辑死锁，最终还是会失败。

#### 1. 内存泄漏防治：定期重启浏览器实例

长时间运行的Puppeteer脚本最大的敌人是**内存泄漏**。Chrome浏览器实例会随着时间不断消耗内存，即使你关闭了所有页面。

**解决方案**：在主循环中加入一个计数器，每执行N次循环（例如100次）后，优雅地关闭当前的`browser`对象，然后重新创建一个新的实例。这会彻底释放所有相关资源。

**修改 `main` 函数：**

```typescript
// --- 3. 主执行逻辑 (Main Execution Logic) ---

// 将浏览器初始化和解锁逻辑拆分出来，方便重复调用
async function setupAndUnlock() {
  const { browser, faucetPage, walletPage } = await initializeBrowser();
  await unlockWallet(walletPage);
  return { browser, faucetPage, walletPage };
}

async function main() {
  console.log('--- Miden Faucet Bot启动 ---');

  const CYCLES_BEFORE_RESTART = 100; // 每100轮重启一次浏览器
  let { browser, faucetPage, walletPage } = await setupAndUnlock();

  // 主循环
  for (let i = 1; i <= CONFIG.MAX_MAIN_LOOP_CYCLES; i++) {
    // 检查是否需要重启浏览器
    if (i > 1 && (i % CYCLES_BEFORE_RESTART === 1)) {
      console.log(`\n--- 达到 ${CYCLES_BEFORE_RESTART} 轮，正在重启浏览器实例以释放内存... ---`);
      await browser.close(); // 彻底关闭旧实例
      ({ browser, faucetPage, walletPage } = await setupAndUnlock()); // 创建新实例并解锁
      console.log('--- 浏览器重启并解锁完成，继续执行任务 ---');
    }

    console.log(`\n--- 开始第 ${i} 轮循环 ---`);

    const faucetSuccess = await requestFromFaucet(faucetPage);
    if (!faucetSuccess) {
      console.error('主循环: 水龙头请求失败，脚本将退出.');
      throw new Error('Faucet request failed after retries.');
    }

    const claimSuccess = await claimInWallet(walletPage);
    if (!claimSuccess) {
      console.error('主循环: 钱包领取失败，脚本将退出.');
      throw new Error('Wallet claim failed after retries.');
    }

    console.log(`--- 第 ${i} 轮循环成功完成 ---\n`);
    await delay(5000); 
  }

  console.log('达到最大循环次数，脚本正常结束。');
  await browser.close();
}
```

#### 2. 确保资源关闭

您的 `main().catch()` 结构很好，但要确保在任何情况下 `browser.close()` 都能被调用。一个更保险的模式是 `try...finally`。

```typescript
async function main() {
  let browser: Browser | null = null;
  try {
    // ... 你的所有逻辑都在这里
    // browser = await puppeteer.launch(...);
    // ...
  } catch (error) {
    console.error('脚本主逻辑发生致命错误', error);
    process.exit(1);
  } finally {
    if (browser) {
      await browser.close();
      console.log('浏览器已在 finally 块中关闭。');
    }
  }
}
```
*注意：由于我们现在有内部重启逻辑，这个顶层的`finally`可能不是必需的，但它是一个很好的编程习惯。*

### 层面二：专业的进程管理 (Process Management)

您的`run.sh`是一个基础的进程管理器。但对于长期运行的服务，我们应该使用专业的工具，例如 **PM2**。

**为什么用 PM2？**
*   **自动重启**：当脚本因任何错误退出时，PM2会立即自动重启它。
*   **日志管理**：自动收集`console.log`和`console.error`到文件中，并支持日志分割和轮转。
*   **性能监控**：可以实时查看脚本的CPU和内存占用。
*   **开机自启**：可以生成一个系统服务，确保服务器重启后脚本能自动运行。

**如何使用 PM2：**

1.  **全局安装 PM2:**
    ```bash
    sudo npm install -g pm2
    ```

2.  **使用 PM2 启动您的脚本 (代替 `./run.sh`):**
    `tsx`是一个执行器，我们需要告诉PM2用`tsx`来运行你的`.ts`文件。

    ```bash
    # 语法: pm2 start <执行器> --name <应用名> -- <执行器的参数>
    pm2 start tsx --name "miden-bot" -- miden_faucet_bot.ts
    ```
    *   `--name "miden-bot"`: 给你的进程起一个容易识别的名字。
    *   `--`: 这个双破折号很重要，它告诉PM2后面的内容是传给`tsx`的参数，而不是PM2自己的参数。

3.  **常用 PM2 命令:**
    ```bash
    pm2 list          # 查看所有正在运行的进程
    pm2 logs miden-bot  # 实时查看 "miden-bot" 的日志
    pm2 restart miden-bot # 重启应用
    pm2 stop miden-bot    # 停止应用
    pm2 delete miden-bot  # 从PM2列表中移除应用
    pm2 monit         # 打开一个漂亮的监控仪表盘
    ```

4.  **设置开机自启:**
    这是实现“不宕机”的关键一步。
    ```bash
    # PM2会分析你的系统（如systemd）并生成配置命令
    pm2 startup
    # 它会输出一行命令，你需要复制并执行它，通常是类似 sudo env ...
    
    # 保存当前PM2中正在运行的进程列表，以便开机时恢复
    pm2 save
    ```

### 层面三：系统环境优化 (System-Level Tuning)

#### 1. 处理僵尸进程 (Zombie Processes)

有时即使脚本退出了，底层的Chrome进程也可能没有被完全杀死，变成“僵尸进程”并耗尽系统资源。PM2虽然能重启脚本，但无法清理这些残留物。

**解决方案**：设置一个`cron`定时任务，定期清理任何无主（父进程ID为1）的或运行时间过长的Chrome进程。

1.  打开crontab编辑器：`crontab -e`
2.  添加一行任务，例如每小时执行一次清理：
    ```crontab
    # 每小时的第5分钟，查找并杀死运行超过60分钟的Chrome进程
    5 * * * * pkill -o -f "chrome" --older-than 1h
    
    # 或者一个更激进的版本，直接杀死所有由你的用户运行的chrome
    # 5 * * * * pkill -u $(whoami) -f "chrome"
    ```
    *   `pkill -o -f "chrome"`: `-o` 表示只杀掉最老的那个进程，`-f` 匹配完整命令行。这是一个相对温和的策略。
    *   `--older-than 1h`: 仅杀死运行超过1小时的进程（需要较新版本的`pkill`）。

#### 2. 增加共享内存大小 (`/dev/shm`)

在Linux上，Puppeteer（Chrome）大量使用`/dev/shm`作为共享内存。如果这个空间太小（默认通常只有64MB），复杂的页面或长时间运行会导致Chrome崩溃。

**解决方案**：在`puppeteer.launch`的`args`中添加`--disable-dev-shm-usage`。这会让Chrome把临时文件写到`/tmp`目录而不是`/dev/shm`。这是最简单且推荐的修复方法。

**修改 `LAUNCH_OPTIONS`:**
```typescript
const LAUNCH_OPTIONS = {
  headless: true, // 已修改为 true
  ignoreDefaultArgs: ['--disable-extensions'],
  args: [
    `--user-data-dir=${CONFIG.USER_DATA_DIR}`,
    '--no-sandbox',
    '--disable-setuid-sandbox', // 在某些Linux环境下需要
    '--disable-dev-shm-usage', // <--- 关键！避免/dev/shm空间不足问题
    '--remote-debugging-port=0',
    '--window-size=1280,800', 
    '--disable-gpu',
    '--disable-features=IsolateOrigins,site-per-process',
  ],
};
```

### 层面四：监控与警报 (Monitoring & Alerting)

你如何知道你的脚本虽然“在运行”，但实际上已经卡住或者没有产出？

1.  **增强日志**：在日志中输出关键的成功指标。
    *   例如，在每次循环成功后，打印 `console.log(\`[SUCCESS] Cycle ${i} completed. Next run in 5s.\`);`
    *   当你看`pm2 logs miden-bot`时，如果长时间没有看到`[SUCCESS]`日志，你就知道出问题了。

2.  **设置外部健康检查 (Health Checks)**：
    对于非常关键的任务，你可以设置一个外部服务（如 UptimeRobot 的心跳监测、Healthchecks.io）来监控你的脚本。
    *   **原理**：你的脚本在每次成功完成一轮循环后，就向一个特定的URL发送一个GET请求。
    *   **监控服务**：监控服务会等待这个请求。如果超过预设时间（例如1小时）没有收到请求，它就会判定你的服务“宕机”了，并通过邮件、短信或Webhook通知你。

**简单实现:**
```typescript
// 在你的脚本中添加一个函数
async function pingHealthCheck() {
    try {
        // 替换成你从Healthchecks.io等服务获取的URL
        const HEALTHCHECK_URL = 'https://hc-ping.com/YOUR-UNIQUE-ID'; 
        await fetch(HEALTHCHECK_URL);
        console.log('[HEALTH] Sent success ping to health check service.');
    } catch (e) {
        console.warn('[HEALTH] Could not send ping to health check service.', e.message);
    }
}

// 在主循环成功后调用它
if (claimSuccess) {
    console.log(`--- 第 ${i} 轮循环成功完成 ---\n`);
    await pingHealthCheck(); // <--- 在这里调用
    await delay(5000); 
}
```

通过这四个层面的加固，你的Puppeteer脚本将从一个简单的自动化脚本，转变为一个能在无人值守的服务器上7x24小时稳定运行的可靠服务。


好的，明白了。我们将结合您现有的逻辑（失败后重启浏览器）和之前讨论的加固方案（PM2、系统优化等），生成一个最终的、高度健壮的生产级脚本。

这个方案的核心是：
1.  **脚本内部处理“软重启”**：当 `requestFromFaucet` 或 `claimInWallet` 失败时，脚本自身会关闭并重启浏览器，然后继续主循环。这是您要求的“重启浏览器继续处理”。
2.  **PM2处理“硬重启”**：当脚本遇到无法处理的致命错误（如初始化失败）或我们主动抛出错误时，脚本会以非零码退出。PM2会捕获这个退出事件，并重启整个`tsx`进程。
3.  **失败计数器**：PM2的 `--max-restarts` 功能可以完美实现您“连续重启3次后中止”的需求。

下面是整合了所有加固方案的最终代码和部署步骤。

---

### 第1步：修改后的完整Typescript脚本

这是 `miden_faucet_bot.ts` 的最终版本。它包含了所有讨论过的加固点。

**主要改动点:**

1.  **`LAUNCH_OPTIONS` 更新**：添加了 `headless: true` 和 `--disable-dev-shm-usage` 等优化参数。
2.  **`CONFIG` 增强**：增加了 `CYCLES_BEFORE_MEMORY_REFRESH`（用于内存泄漏防治）和 `HEALTHCHECK_URL`（用于可选的外部监控）。
3.  **`main` 函数重构**：
    *   逻辑核心变为一个大 `try...catch...finally` 块，确保浏览器在任何情况下都能被关闭。
    *   引入了 `softRestartCounter` 来追踪浏览器内部的重启次数，但这个功能被PM2的机制替代了，所以我们简化了逻辑。
    *   现在，当 `requestFromFaucet` 或 `claimInWallet` 失败时，它会**直接抛出异常**，而不是尝试自己重启浏览器。这是为了让PM2来接管重启，从而实现“连续重启3次中止”的逻辑。
    *   加入了**定期内存刷新**逻辑（每100次循环重启一次浏览器）。
4.  **`pingHealthCheck` 函数**：增加了可选的健康检查功能。
5.  **日志更清晰**：在关键节点增加了更详细的日志输出。


```

---

### 第2步：使用PM2进行部署和管理

现在，我们不再需要 `run.sh`。PM2将成为我们的进程守护神。

1.  **全局安装PM2 (如果还没装):**
    ```bash
    sudo npm install -g pm2
    ```

2.  **启动脚本并设置重启策略:**
    这是最关键的一步。我们将使用PM2的`--max-restarts`和`--restart-delay`参数。

    ```bash
    # 启动命令
    pm2 start tsx --name "miden-bot" -- --max-restarts 3 --restart-delay 10000 miden_faucet_bot.ts
    ```
    分解这个命令：
    *   `pm2 start tsx`: 使用PM2启动`tsx`执行器。
    *   `--name "miden-bot"`: 给应用命名。
    *   `--`: PM2参数结束，后面是给`tsx`的参数。
    *   `--max-restarts 3`: **这是实现您需求的核心。** 如果脚本在短时间内（由`--min-uptime`决定，默认为1秒）连续快速失败重启超过3次，PM2将停止尝试重启，并将进程状态置为`errored`。
    *   `--restart-delay 10000`: 在脚本失败后，等待10秒（10000毫秒）再进行重启。这给了系统喘息的时间。
    *   `miden_faucet_bot.ts`: 要执行的脚本文件。

3.  **管理和监控:**
    *   **查看状态**: `pm2 list` 或 `pm2 status`
        *   你会看到 `miden-bot` 的状态。如果它连续失败超过3次，`status` 会变成 `errored`，`restarts` 计数器会显示3。
    *   **查看日志**: `pm2 logs miden-bot`
        *   所有`console.log`和`console.error`都会在这里显示。
    *   **重置失败计数器并重启**: 如果你想在修复问题后手动重启，可以：
        ```bash
        pm2 restart miden-bot --update-env
        # 这会重置重启计数器
        ```

4.  **设置开机自启:**
    ```bash
    pm2 startup
    # 按照提示执行它输出的命令
    pm2 save
    ```

---

### 第3步：系统级加固 (Cron Job)

这个步骤是可选的，但强烈推荐，用于防止僵尸进程。

1.  编辑 `crontab`: `crontab -e`
2.  添加以下行，每小时检查一次并清理运行超过1小时的残留Chrome进程。

    ```crontab
    5 * * * * pkill -o -f "chrome" --older-than 1h
    ```
    这可以确保即使发生最坏的情况，您的服务器资源也不会被耗尽。

### 总结

这个全新的工作流程是：

1.  **`miden_faucet_bot.ts`**: 负责核心业务逻辑。它经过加固，能处理内存刷新。当遇到无法自行解决的错误时（如连续两次操作失败），它会**干净利落地抛出异常并退出**。
2.  **`PM2`**: 担任“主管”的角色。它负责：
    *   启动并监视脚本进程。
    *   在脚本退出时（即发生错误时）**自动重启**。
    *   记录重启次数，当**连续失败达到3次**时，停止重启并标记为错误，**完美实现了您的需求**。
    *   管理日志和开机自启。
3.  **`Cron Job`**: 担任“保洁员”的角色，定期清理系统，防止意外情况下的资源泄漏。

这个三层结构（应用逻辑层、进程管理层、系统保障层）为您提供了一个非常健壮、可靠的自动化解决方案，能够满足长期稳定运行的要求。
